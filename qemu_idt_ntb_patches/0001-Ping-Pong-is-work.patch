From 00b3b7e577bf864652f3db90b05d32406c706a76 Mon Sep 17 00:00:00 2001
From: name <you@example.com>
Date: Tue, 11 Jul 2023 12:51:18 +0000
Subject: [PATCH] Ping Pong is work

---
 hw/misc/ivshmem.c | 103 ++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 95 insertions(+), 8 deletions(-)

diff --git a/hw/misc/ivshmem.c b/hw/misc/ivshmem.c
index a2872324a3..6f2f439195 100644
--- a/hw/misc/ivshmem.c
+++ b/hw/misc/ivshmem.c
@@ -47,7 +47,7 @@
 #define IVSHMEM_IOEVENTFD   0
 #define IVSHMEM_MSI     1
 
-#define IVSHMEM_REG_BAR_SIZE 0x100
+#define IVSHMEM_REG_BAR_SIZE 0x1000
 
 #define IVSHMEM_DEBUG 1
 #define IVSHMEM_DPRINTF(fmt, ...)                       \
@@ -117,6 +117,10 @@ struct IVShmemState {
     /* migration stuff */
     OnOffAuto master;
     Error *migration_blocker;
+
+    /* Fields for IDT */
+    uint64_t gasaaddr;
+    uint64_t nt_mtb_addr;
 };
 
 /* registers for the Inter-VM shared memory device */
@@ -177,9 +181,22 @@ static void ivshmem_io_write(void *opaque, hwaddr addr,
     uint16_t dest = val >> 16;
     uint16_t vector = val & 0xff;
 
-    addr &= 0xfc;
+    //addr &= 0xfc;
 
-    IVSHMEM_DPRINTF("writing to addr " HWADDR_FMT_plx "\n", addr);
+    IVSHMEM_DPRINTF("Writing to addr " HWADDR_FMT_plx " value 0x%lx\n", addr, val);
+    switch (addr){
+        case 0xFF8U:  // GASAADDR
+            s->gasaaddr = val;
+            break;
+        case 0x4D0U:  // IDT_NT_NTMTBLADDR
+            s->nt_mtb_addr = val & (0x7FU);  // Set partion number to interact with mapping table (First six bits)
+            break;
+        default:
+            IVSHMEM_DPRINTF("Invalid addr " HWADDR_FMT_plx  " for config space\n", addr);
+    }
+    return;
+    /* Ivshmem code 
+     * ============ */
     switch (addr)
     {
         case INTRMASK:
@@ -211,13 +228,62 @@ static void ivshmem_io_write(void *opaque, hwaddr addr,
     }
 }
 
+static uint64_t get_gasadata(IVShmemState *s){
+    uint64_t ret;
+    switch (s->gasaaddr){
+        case 0x3E204U:  // IDT_SW_SWPORT0STS
+            ret = 0;
+            ret |= 0x1 << 4;  // Link up, data link layer is 'DL_up'
+            //ret = 1 << 5;  // Link mode is downstream
+            ret |= 0 << 10;  // Partion is 0x0
+            ret |= 0x3 << 6;  // NT Function is enabled
+            break;
+        case 0x3E244U:  // IDT_SW_SWPORT2STS
+            ret = 0;
+            ret |= 0x1U << 4;  // Link up, data link layer is 'DL_up'
+            //ret = 1 << 5;  // Link mode is downstream
+            ret |= 0U << 10;  // Partion is 0x0
+            ret |= 0x3U << 6;  // NT Function is enabled
+            break;
+        case 0x3E104U:  // IDT_SW_SWPART0STS
+            ret = 0;
+            ret |= 1U << 5;  // Part is enabled
+            break;
+        case 0x5004U:  // IDT_SW_NTP2_PCIECMDSTS
+            ret = 0;
+            ret |= 0x1U << 2;  // Bus Master is enabled
+            break;
+        case 0x5400U:  // IDT_SW_NTP2_NTCTL
+            ret = 0;
+            ret |= 0x1 << 1;  // Completion is enabled (CPEN flag)
+            break;
+        default:
+            IVSHMEM_DPRINTF("Not implemented gasadata on reg 0x%lx\n", s->gasaaddr);
+            ret = 0;
+    }
+    return ret;
+}
+
+static uint64_t get_nt_mtb_data(IVShmemState *s){
+    uint64_t ret;
+    switch (s->nt_mtb_addr){
+        case 0x0U:  // Partion 0
+            ret = 0;
+            ret |= 0x1;  // Set VALID field
+            break;
+        default:
+            IVSHMEM_DPRINTF("Not implemented nt_mtb_addr on value 0x%lx\n", s->nt_mtb_addr);
+            ret = 0;
+    }
+    return ret;
+}
+
 static uint64_t ivshmem_io_read(void *opaque, hwaddr addr,
                                 unsigned size)
 {
 
     IVShmemState *s = opaque;
-    uint32_t ret;
-    IVSHMEM_DPRINTF("Reading at " HWADDR_FMT_plx "\n", addr);
+    uint64_t ret;
 
     switch (addr)
     {
@@ -225,20 +291,41 @@ static uint64_t ivshmem_io_read(void *opaque, hwaddr addr,
             ret = ivshmem_IntrMask_read(s);
             break;
 
-        case INTRSTATUS:
+        /*case INTRSTATUS:
             ret = ivshmem_IntrStatus_read(s);
-            break;
+            break;*/
 
         case IVPOSITION:
             ret = s->vm_id;
             break;
 
+        case 0xFFCU:  // GASADATA
+            ret = get_gasadata(s);
+            break;
+        case 0x4CU:  // IDT_NT_PCIELCAP
+            ret = 0;
+            ret |= 0x0U << 24;  // Local port number is 0x0
+            break; 
+        case 0x4U:  // IDT_NT_PCICMDSTS
+            ret = 0;
+            ret |= 0x1U << 2;  // Bus Master is enabled
+            break;
+        case 0x400U:  // IDT_NT_NTCTL
+            ret = 0;
+            ret |= 0x1 << 1;  // Completion is enabled (CPEN flag)
+            break;
+        case 0x4D8U:  // IDT_NT_NTMTBLDATA
+            ret = get_nt_mtb_data(s);
+            break;
         default:
             IVSHMEM_DPRINTF("why are we reading " HWADDR_FMT_plx "\n", addr);
             ret = 0;
     }
 
+    IVSHMEM_DPRINTF("Readed value 0x%lx at " HWADDR_FMT_plx "\n", ret, addr);
     return ret;
+    // Preverse -Wunused
+    ret = ivshmem_IntrStatus_read(s);
 }
 
 static const MemoryRegionOps ivshmem_mmio_ops = {
@@ -841,7 +928,7 @@ static uint32_t ivshmem_read_config(PCIDevice *pdev, uint32_t address,
     ret = pci_default_read_config(pdev, address, len);
     IVSHMEM_DPRINTF("Default config value at address 0x%x is 0x%x\n", address, ret);
     switch(address){
-        case 0x470: // IDT_NT_BARSETUP0
+        case 0x470U: // IDT_NT_BARSETUP0
             ret = 0;
             ret |= (0x0U << 1);
             ret |= (0xCU << 4);  // Six bits
-- 
2.30.2

